
package net.ccbluex.liquidbounce.features.module.modules.exploit.phases.other

import net.ccbluex.liquidbounce.event.MoveEvent
import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.features.module.modules.exploit.phases.PhaseMode
import net.ccbluex.liquidbounce.utils.MovementUtils
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.utils.ClientUtils
import net.ccbluex.liquidbounce.utils.timer.TickTimer
import net.minecraft.network.play.client.C03PacketPlayer
import net.minecraft.network.play.server.S08PacketPlayerPosLook
import kotlin.math.cos
import kotlin.math.sin

class Matrix : PhaseMode("Matrix") {
    private var matrixClip = false
    private val ticktimer = TickTimer()
    override fun onEnable() {
        matrixClip = false
        ticktimer.reset()
    }

    override fun onMove(event: MoveEvent) {
        if (mc.thePlayer.isCollidedHorizontally) matrixClip = true
        if (matrixClip) {
            mc.timer.timerSpeed = 0.3f
            ticktimer.update()
            event.x = 0.0
            event.z = 0.0
            if (ticktimer.hasTimePassed(3)) {
                ticktimer.reset()
                matrixClip = false
            } else if (ticktimer.hasTimePassed(1)) {
                val offset = if (ticktimer.hasTimePassed(2)) 1.6 else 0.2
                val direction = MovementUtils.direction
                mc.thePlayer.setPosition(mc.thePlayer.posX + -sin(direction) * offset, mc.thePlayer.posY, mc.thePlayer.posZ + cos(direction) * offset)
            }
        } else {
            mc.timer.timerSpeed = 1f
            return
        }
    }
    override fun onPacket(event: PacketEvent) {
        val packet = event.packet
        if (packet is S08PacketPlayerPosLook) {
            ClientUtils.displayChatMessage("flag")
            event.cancelEvent()
            PacketUtils.sendPacketNoEvent(C03PacketPlayer.C06PacketPlayerPosLook(packet.x, packet.y, packet.z, packet.getYaw(), packet.getPitch(), true))
        }
    }
}
