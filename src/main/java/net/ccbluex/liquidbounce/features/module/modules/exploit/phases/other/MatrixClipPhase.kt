
package net.ccbluex.liquidbounce.features.module.modules.exploit.phases.other

import net.ccbluex.liquidbounce.event.MoveEvent
import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.features.module.modules.exploit.phases.PhaseMode
import net.ccbluex.liquidbounce.utils.MovementUtils
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.utils.ClientUtils
import net.ccbluex.liquidbounce.utils.timer.TickTimer
import net.ccbluex.liquidbounce.value.FloatValue
import net.ccbluex.liquidbounce.value.BoolValue
import net.minecraft.network.play.client.C03PacketPlayer
import net.minecraft.network.play.server.S08PacketPlayerPosLook
import kotlin.concurrent.timer
import kotlin.math.cos
import kotlin.math.sin

class MatrixClipPhase : PhaseMode("MatrixClip") {
    private var matrixClip = false
    private var flagCount = 0
    private val ticktimer = TickTimer()
    private val timerValue = FloatValue("${valuePrefix}timer", 0.3f,0.1f,1f)
    private val clipDist = FloatValue("${valuePrefix}initialClipDistance", 0.1f, 0.03f, 0.3f)
    private val showFlags = BoolValue("${valuePrefix}showFlags", true)
    override fun onEnable() {
        matrixClip = false
        ticktimer.reset()
        flagCount = 0
    }

    override fun onMove(event: MoveEvent) {
        if (flagCount > 5) return
        
        if (mc.thePlayer.isCollidedHorizontally)
            matrixClip = true

        if (matrixClip) {
            mc.timer.timerSpeed = timerValue.get()
            ticktimer.update()
            event.x = 0.0
            event.z = 0.0
            if (ticktimer.hasTimePassed(3)) {
                ticktimer.reset()
                matrixClip = false
            } else if (ticktimer.hasTimePassed(1)) {
                val offset = if (ticktimer.hasTimePassed(2)) 1.6 else clipDist.get().toDouble()
                val direction = MovementUtils.direction
                mc.thePlayer.setPosition(mc.thePlayer.posX + -sin(direction) * offset, mc.thePlayer.posY, mc.thePlayer.posZ + cos(direction) * offset)
            }
        } else {
            mc.timer.timerSpeed = 1f
            return
        }
    }
    override fun onPacket(event: PacketEvent) {
        val packet = event.packet
        if (packet is S08PacketPlayerPosLook) {
            if (showFlags.get())
                ClientUtils.displayChatMessage("flag")
            
            flagCount++
            
            if (flagCount > 5)
                ClientUtils.displayChatMessage("Flagged too much, phase stopped")
                
            event.cancelEvent()
            PacketUtils.sendPacketNoEvent(C03PacketPlayer.C06PacketPlayerPosLook(packet.x, packet.y, packet.z, packet.getYaw(), packet.getPitch(), true))
        }
    }
}
