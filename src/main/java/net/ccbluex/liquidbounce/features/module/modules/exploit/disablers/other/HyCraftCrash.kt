package net.ccbluex.liquidbounce.features.module.modules.exploit.disablers.other

import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.UpdateEvent
import net.ccbluex.liquidbounce.event.WorldEvent
import net.ccbluex.liquidbounce.features.module.modules.exploit.disablers.DisablerMode
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.IntegerValue
import net.minecraft.entity.monster.EntityEnderman
import net.minecraft.entity.monster.EntityGuardian
import net.minecraft.network.play.server.S0FPacketSpawnMob
import net.minecraft.network.play.server.S2APacketParticles
import net.minecraft.network.play.server.S3EPacketTeams

class HyCraftCrash : DisablerMode("HyCraftCrash") {
    private val autoleaveValue = BoolValue("${valuePrefix}AutoQuit", true)
    private val maxMobs = IntegerValue("${valuePrefix}MaxMobSpawn", 50, 20, 100)
    private val maxParticles = IntegerValue("${valuePrefix}MaxParticles", 40, 10, 100)
    private val timer = MSTimer()
    private var count = 0
    private var needChat = false
    override fun onEnable() {
        timer.reset()
        count = 0
        needChat = false
    }

    override fun onWorld(event: WorldEvent) {
        timer.reset()
        count = 0
        needChat = false
    }
    override fun onPacket(event: PacketEvent) {
        val packet = event.packet
        if(packet is S0FPacketSpawnMob) {
            count++
            if(count > maxMobs.get()) {
                event.cancelEvent()
                needChat = true
            } else if(needChat) {
                disabler.debugMessage("Blocked Mobs : $count")
                needChat = false
                count = 0
            }
        }
        if (packet is S3EPacketTeams) {
            event.cancelEvent()
//            disabler.debugMessage("Disabled Team Packet : " + packet.players)
        }
        if(packet is S2APacketParticles) {
            if(packet.particleCount > maxParticles.get()) {
                disabler.debugMessage("Blocked Particles: " + packet.particleCount)
                event.cancelEvent()
                if(packet.particleCount > 1024 && autoleaveValue.get()) {
                    mc.theWorld.sendQuittingDisconnectingPacket()
                }
            }
        }
    }

    override fun onUpdate(event: UpdateEvent) {
        mc.theWorld.loadedEntityList.forEach {
            if(it is EntityEnderman || it is EntityGuardian) {
                mc.theWorld.removeEntity(it)
                disabler.debugMessage("Remove Entity: " + it.name)
                if(autoleaveValue.get()) {
                    mc.theWorld.sendQuittingDisconnectingPacket()
                }
            }
        }
    }
}
